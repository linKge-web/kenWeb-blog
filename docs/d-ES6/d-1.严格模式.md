## 1.严格模式的概述

ECMAScript 5 引入了 `strict mode` ,现在已经被大多浏览器实现(包括IE10. 会使web浏览器更容易的解析代码(只需要在源码上面添加 "`use strict`";), 由现有的代码到严格模式的过渡需要一些事做。

**设立严格模式的目的：**
> - 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;  
> - 消除代码运行的一些不安全之处，保证代码运行的安全；   
> - 提高编译器效率，增加运行速度；   
> - 为未来新版本的Javascript做好铺垫。   

除此之外，同样的代码，在"严格模式"中可能会有不一样的运行结果;一些在"正常模式"下能正常运行的语句在”严格模式“下不能运行。全面掌握这些内容有助于更加深入理解JavaScript。

### 1.1 严格模式的使用

- 如果是整个脚本文件，在整个文件的首行添加`use strict`,则整个文件就会以严格模式运行。
- 如果单个函数，在函数体的首行添加`use stirct`，则整个函数体就能以严格模式运行。

> 如果是一些老版本的浏览器不支持，就会把这条语句当做简单的普通字符串，直接忽略。

实际上，只要前面不是产生实际运行结果的语句，"use strict"可以不在第一行，比如直接跟在一个空的分号后面。

**脚本文件的变通写法：**
上面介绍的这种写法不利于文件的合并，所以更好的做法是：将整个脚本文件放在一个立即执行的匿名函数之中。比如：

```js
(function(){
    "use strict";
    //some code here...
})();
```

### 1.2 严格模式与普通模式的区别

#### 1.2.1 全局变量显示声明
在普通模式下，如果一个变量没有声明就赋值，则这个变量就会默认为全局变量。    
在严格模式下，必须先用var声明才能使用变量，否则就会把报错（未声明）。

#### 1.2.2 只允许静态绑定
JavaScript语言是属于“动态绑定”的，也就是说，属性和方法属于哪一个对象不在编译阶段确定的， 而是在运行的时候才确定的。   
而在严格模式中在某些情况下，只允许静态绑定，也就是说，属性和方法属于哪个对象在编译的时候就已经确定了，这样可以是编译效率更高，也使得代码更加容易阅读，更少出现一些意外的问题。  
**具体来讲分为两部分**
- （1）**禁止使用with语句**。因为with无法在编译的时候就确定这个属性到底是属于那个对象。
```JS
"use strict"
let num = 1;
with(o) {
    num = 2;
}
// error: Strict mode code may not include a with statement
```
- （2）**创设了eval作用域**。eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。
> 正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。     
正常模式下，eval语句的作用域，取决于它是处于全局作用域，还是处于函数作用域。
```js
var x = 5;
console.log(eval("var x = 2; x")); // 2
console.log(x);// 5
```

#### 1.2.3 禁止this关键字指向全局对象
使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。
```js
var fun = function() {
    console.log(this);
}
fun();   //undefined
````
在普通模式下打印的是window，而在严格模式打印的是undefined。

#### 1.2.4 禁止在函数内部遍历调用栈

#### 1.2.5 禁止删除变量
严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。
```js
"use strict";
var num;
// delete num;  //Delete of an unqualified identifier in strict mode
var obj = Object.create(null,{'num':{
    value: 1234,
    configurable: true  
}})
delete obj.num;
console.log(obj.num);  //undefined
```
#### 1.2.6 属性相关
- 正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。在严格模式下就会报错。
- 严格模式下，对一个使用getter方法读取的属性进行赋值会报错。
```js
"use strict"
var obj = {
　　get val(){ return 1; }
}
obj.val = 2; // 报错
//Cannot set property val of #<Object> which has only a getter
```
- 严格模式下，对禁止扩展的对象添加新属性，会报错。
- 严格模式下，删除一个不可删除的属性，会报错。
```js
"use strict";
delete Object.prototype; // 报错
```

#### 1.2.7 重名报错
* 对象不能有重名的属性
* 函数不能有重名的参数  
正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。

#### 1.2.8 禁止使用八进制
正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。

#### 1.2.9 对arguments对象的限制
- 不允许对arguments赋值
- arguments不再追踪参数的变化
- 禁止使用arguments.callee  
也就是说，你无法在匿名函数内部调用自身了。
```js
var f = function() { 
    return arguments.callee; 
};
f(); 
// 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
```

#### 1.2.10 函数必须声明在顶层

将来Javascript的新版本会引入"块级作用域"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。

#### 1.2.11 新增关键字

为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。

### 1.3 总结

面试的时候至少能打上5条。



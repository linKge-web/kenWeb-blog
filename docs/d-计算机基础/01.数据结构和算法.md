## 1.栈
栈是一个线性结构，在计算机中是一种相当常见的数据结构。
### 1.1 栈与数组对比
我们知道数组是一种**线性结构**，并且可以在数组的**任意位置**插入和删除数据。但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。而**栈和队列**就是比较常见的**受限线性结构**，我们先从栈开始介绍。
![](./img/栈01.png "图片标题") 
栈的特点：**先进先出（LIFO）**
- 其限制是仅允许在**表的一端**进行插入和删除运算，这一端被称为**栈顶**，相对地，把另一端称为**栈底**。
- LIFO表示就是后进入的元素，第一个弹出栈空间，类似自动餐托盘，最后放上的托盘，往往先把它拿出去使用。
- 向一个栈插入新元素又称**进栈、入栈**或者**压栈**，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；
- 从一个栈删除元素又称作**出栈**或者**退栈**，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
### 1.2 栈的实现
#### 1.2.1 栈的常见操作
- push（element）：添加一个新元素到栈顶位置；
- pop（）：移除栈顶的元素，同时返回被移除的元素；
- peek（）：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）；
- isEmpty（）：如果栈里没有任何元素就返回true，否则返回false；
- size（）：返回栈里的元素个数。这个方法和数组的length属性类似；
- toString（）：将栈结构的内容以字符串的形式返回。
#### 1.2.2 栈的封装
```js
//封装栈类
function Stack() {
    //栈中的属性
    this.items = [];

    //栈的相关操作
    //1.push(): 将元素压入栈
    //方法一（不推荐）：给当前兑现添加的方法，其他对象不能使用
    /* this.push = () => {

    } */

    //方法二：给Stack的原型上添加方法，能够给多个对象使用
    Stack.prototype.push = function(element) {
        this.items.push(element);
    }

    //2.pop(): 从栈中取出元素
    Stack.prototype.pop = function() {
        return this.items.pop(); //返回最后一个元素，也就是栈顶元素
    }

    //3.peek(): 查看栈顶元素
    Stack.prototype.peek() = function() {
        return this.items[this.items.length - 1];
    }

    //4. isEmpty(): 判断栈是否为空
    Stack.prototype.isEmpty() = function() {
        return this.items.length === 0;
    }

    //5.size(): 获取栈中元素的个数
    Stack.prototype.size() = function() {
        return this.items.length;
    }

    //6.toString(): 以字符串的形式输出栈的元素
    Stack.prototype.toString() = function() {
        //希望输出的形式：20 10 12 8 7
        var retString = '';
        for(var i = 0;i<this.items.length;i++) {
            retString += items[i] + ' ';
        }
        return retString;
    }
}
```

#### 1.2.3 栈的操作的使用
```js
let s = new Stack();
// 入栈
s.push(12);
s.push(23);
s.push(34);
s.push(45);

console.log(s);
// [12,23,34,45]

//取出栈顶元素
console.log(s.pop());   //45
console.log(s);         //[12,23,34]

//查看栈顶元素
console.log(s.peek()); //34
// 判断栈是否为空
console.log(s.isEmpty()); //false
//查看栈中元素的个数
console.log(s.size());  //3
// 以字符串的形式输出栈内的元素
console.log(s.toString());  //'12,23,34'

```
#### 1.2.4 栈的应用 —— 十进制转二进制
利用栈结构的特点封装十进至转换为二进至的函数：
> 100 --> 1100100   
100/2 ==> 余数 0    
50/2  ==> 余数 0    
25/2  ==> 余数 1    
12/2  ==> 余数 0    
6/2   ==> 余数 0    
3/2   ==> 余数 1    
1/2   ==> 余数 1    

代码实现：
```js
// 函数：将十进制转成二进制
function dec2bin(decNumber) {
    //1.定义一个栈，保存余数
    var stack = new Stack();

    //2.循环操作
    while(decNumber) {
        //2.1 获取余数，并且放入到栈中
        stack.push(decNumber % 2);

        //2.2 获取整除后的结果，用于下一次循环
        decNumber = Math.floor(decNumber / 2);  //floor向下取整
    }

    //3.从栈中取出0和1
    var bindaryString = '';
    while(!stack.isEmpty()) {
        bindaryString += stack.pop();
    }
    return bindaryString;
}

//测试
console.log(dec2bin(100));  //1100100
console.log(dec2bin(1000));  //1111101000
```

#### 1.2.5 刷题练习
##### 1.2.5.1 有效的括号
>  题目来源：[leetcode20题](https://leetcode-cn.com/problems/valid-parentheses/)

实现代码：
```js
var isValid = function(s) {
    let map = {
        '(': 1,
        ')': -1,
        '[': 2,
        ']': -2,
        '{': 3,
        '}': -3
    }
   let stack = [];
   for(let i=0;i<s.length;i++) {
       if(map[ s[i] ] > 0) {
        stack.push(s[i]);
       }else{
           let last = stack.pop();
           if(map[last] != -(map[ s[i] ])){
               return false;
           }
       }
   }
   if(stack.length > 0) {
        return false;
   }
   return true;
};
```
##### 1.2.5.2 包含迷min函数的栈
> 题目来源：剑指offer

思路：
*   定义两个栈，一个用来存储数据，一个用来存最小的元素。
*   首先把数据进入数据栈
*   每次进栈的时候，都将进栈的数据和最小值栈的顶元素进行比较，如果比栈顶值小就把该数加入最小值栈
*   如果比最小值栈的栈顶元素大，那就把最小值栈的栈顶元素再次（复制）插入最小值栈中。
*   在出栈的时候，需要删除最小值栈的栈顶元素，即最小值栈和数据站都应该出栈。
*   这样最小值栈的栈顶元素就永远都是当前栈的最小值

以数据[3,4,2,7,9,0]为例，让这组数字依次如栈，则栈和其对应的最小值栈如下：
![](./img/栈02.png "图片标题") 
```js
//首先定义两个栈
var dataStack = [];
var minStack = [];
//进栈函数
function push(node) {
    // 首选不管怎么，数据栈都会进栈
    dataStack.push(node);
    // 如果node比最小值栈的栈顶元素小那就把node进入最小值栈，否则就把最小值栈再次（复制）再次入最小值栈
    if (minStack.length === 0 || node < min()) {
        minStack.push(node);
    }else {
        minStack(min());
    }
}
//出栈函数
// 出栈的时候数据栈出栈，最小值栈删掉栈顶元素，
function pop() {
    minStack.pop();
    return dataStack.pop();
}
// 获取最小值栈的栈顶元素
function min() {
    var length = minStack.length;
    return minStack[length - 1]&&length > 0;  //栈不空才能返回
}
```

##### 1.2.5.3 栈的引入和弹出，序列
[题目]
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。
假设压入栈的所有数字均不相等。
例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
（注意：这两个序列的长度是相等的）

> 题目来源：牛客网-剑指offer

思路：

*   首先判断给出的这两个栈序列是否存在并且不为空
*   然后借助一个工作站，来存放压入栈的弹出过程
*   遍历压入栈，然后依次存入工作站中
*   如果工作栈的栈顶元素和弹出栈的栈顶元素相同，工作站就出栈，并且弹出栈的索引往后移
*   如果不同就继续将压入栈元素压入工作栈继续，相当于入栈
*   最后如果工作站为空就说明第二个序列是第一个序列的弹出顺序
![](./img/栈03.png "图片标题") 
```js
//传入两个栈序列，一个是压入栈，一个是弹出栈
function IsPopOrder(pushV,popV) {
    //首先判断这两个栈是否存在并且不为空
    if(pushV || popV || pushV.length === 0 || popV.length === 0 ) {
        return;
    } 
    var workStack = [];  //定义一个工作栈
    var outIndex = 0;  //在弹出栈中移动的索引
    for(var i=0;i<pushV.length;i++) {
        // 从栈底开始把压入栈的元素放入工作栈中
        workStack.push(pushV[i])
        //工作栈栈顶元素和弹出栈索引位置相同的话，工作站出栈，并且索引后进一位
        while(workStack.length && workStack[workStack.length - 1] === popV[outIndex]) {
            workStack.pop();
            outIndex ++;
        }
    }
    // 如果工作栈最后为空，说明弹出栈就是压入栈的出栈序列
    return workStack.length === 0;
}
```

## 2. 队列
队列是一种首先的线性表，**先进先出（FIFO）**
- 受限之处在于它只允许在标的前端进行删除操作
- 而在表的后端进行插入操作
### 2.1 队列的现实应用
- 打印队列：计算机打印多个文件的时候，需要排队打印；
- 线层队列：在开发中，为了让人物可以并行处理，通常会开启多个线程，当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待CPU处理。
### 2.2 队列的实现
队列的实现和栈一样，有两种方案：
- 基于数组实现
- 基于链表实现

#### 2.2.1 队列的常见操作：
- enqueue（element）：向队列尾部添加一个（或多个）新的项；
- dequeue（）：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素；
- front（）：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与Stack类的peek方法非常类似）；
- isEmpty（）：如果队列中不包含任何元素，返回true，否则返回false；
- size（）：返回队列包含的元素个数，与数组的length属性类似；
- toString（）：将队列中的内容，转成字符串形式；
#### 2.2.2 队列的封装
```js
function Queue() {
    //属性
    this.items = [];

    //方法
    // 1.enqueue():将元素加入到队列中
    Queue.prototype.enqueue = element => {
        this.items.push(element);
    }
    //2.dequeue():从队列中删除前端元素
    Queue.prototype.dequeue = () => {
        return this.items.shift();  //删除第一个元素
    }
    //3.fromt():查看前端元素
    Queue.prototype.front = () => {
        return this.items[0];
    }
    //4.isEmpty:查看队列是否为空
    Queue.prototype.isEmpty = () => {
        return this.items.lenght == 0;
    }
    //5.size():查看队列中元素的个数
    Queue.prototype.size = () => {
        return this.items.lenght;
    }
    //6.toString():将队列中元素以字符串形式输出
    Queue.prototype.toString = () => {
        let retString = '';
        for(let i=0;i>this.items.lenght;i++) {
            retString += this.items[i] + ' ';
        }
        return retString;
    }
}
```
#### 2.2.3 队列的操作的使用

```js
// 使用测试
let queue = new Queue();

//添加元素  入队
queue.enqueue('abc');
queue.enqueue('nba');
queue.enqueue('mba');
queue.enqueue('cba');
console.log(queue);  //['abc','nba','mba','cba']

//出队。删除元素
queue.dequeue();
console.log(queue);  //['abc','nba','mba']

//查看队列头部元素
console.log(queue.front()); //'nba'
//查看队列是否为空
console.log(queue.isEmpty());  //false

//查看队列中的元素个数
console.log(queue.size());  //3

//将队列中元素以字符串形式输出
console.log(queue.toString());  //nba mba cba 
```
### 2.3 队列的应用 -- 面试题
**击鼓传花: **

游戏规则：几个朋友一起玩一个游戏，围成一圈，开始数数，数到某个数字的的人自动退出淘汰，最后剩下的这个人会获得胜利，请问最后剩下的是原来哪个位置上的人。
程序规则：击鼓传花，使用队列实现，在队列中传入一组数据和设定的数字num，循环遍历数组内元素，遍历到的元素为指定数字num时将该元素删除，直至数组剩下一个元素。
```js
function passGame(nameList,num) {
    //1.创建一个队列
    let queue = new Queue();

    //2.将所有人添加
    for(let item of nameList) {
        queue.enqueue(item);
    }
    //3.开始数数
    
    // 一直循环数到队列只剩下一个人
    while(queue.size() > 1) {
        //不是num的时候，重新添加到队列的末尾
        //是num的时候，就把这个元素从队列中删除
        for(let j=1;j<num;j++) {
            //都不是num
            queue.enqueue(queue.dequeue());
        }
        queue.dequeue();
    }
    console.log("队列的长度：" + queue.size());
    var endName = queue.front();
    console.log("最后留下来的名字：" + endName);

    return nameList.indexOf(endName);
}

names = ['aaa','bbb','ccc','ddd','eee']; 
console.log(passGame(names,3));  //3
```
### 2.4 优先级队列
#### 2.4.1 优先级队列和普通队列的区别
- 普通队列插入一个元素，数据会被放在后端，并且需要所有的元素都处理完成后才能处理前面的数据。
- 优先级队列在插入一个元素的时候回考虑这个数据的优先级。和其他数据优先级进行比较。比较完成后可以知道这个元素在队列中应该插入的位置。
- 其他方式和普通队列一样

#### 2.4.2 优先级队列的实现
实现优先级队列需要考虑两个方面：
- 封装元素和优先级放在一起（可以封装一个新的构造函数）
- 添加元素时，将新插入元素的优先级和队列中已经存在的元素优先级进行比较，以获得自己正确的位置。

**代码实现：**
```js
//封装优先级队列 以下代码基于ES5
function PriorityQueue() {
    //内部类：在类里面再封装一个类;表示带优先级的数据
    function QueueElement(element,priority) {
        this.element = element;
        this.priority = priority;
    }

    //封装属性
    this.items = [];

    //1.enqueue(): 实现插入方法
    PriorityQueue.prototype.enqueue = function(element,priority) {
        //1.1 创建QueueElement对象
        var queueElement = new QueueElement(element,priority)

        // 2. 判断队列是否为空，如果为空就直接插入进去，如果不为空，就需要从头遍历比较他们的优先级
        if(this.items.length === 0) {
            this.items.push(queueElement);
        }else {
            var added = false;  //用来判断是否插入
            for(var i=0;i<this.items.length;i++) {
                //比较优先级
                if(queueElement.priority < this.items[i],priority) {
                    this.items.splice(i,0,queueElement); //从索引开始删除0个元素，并插入queueElement
                    added = true;
                    break;
                }
            }
            if(!added) {
                this.items.splice(queueElement);
            }
        }
    }

    //toString()
    PriorityQueue.prototype.toString = function() {
        var restString = "";
        for(var i=0;i<this.items.length;i++) {
            restString += this.items[i].element + '-' + this.items[i].priority + " ";
        }
        return restString;
    }
    //其他方法和普通队列一样
}
//测试代码
var pq = new PriorityQueue()

pq.enqueue('abc',111);
pq.enqueue('cba',222);
pq.enqueue('nba',50);
pq.enqueue('nba',300);
console.log(pq.toString());
//nba-300 nba-50 cba-222 abc-111 
``` 

## 3.栈和队列练习
### 3.1 用两个栈来实现一个队列
完成队列的Push和Pop操作。 队列中的元素为int类型。
思路：定义两个栈1和栈2
栈1：用于存储队列
栈2：出队列的时候，栈1的数据依次出栈并进入栈2中，栈2出栈也就是栈1底部出栈的顺序，也就是队列中出栈的次序。
注意：猪油栈2为空的时候，栈1才能够进数据，否则会打乱出队列的次序。
![](./img/栈和队列01.png)

```js
const stack1 = [];
const stack2 = [];
//入栈函数
function push(node) {
    stack1.push(node);
}
//出栈函数
function pop() {
    //先判断栈2是否为空，为空的话才进栈
    if(stack2.length === 0) {
        //并且栈1的不为空，然后栈1出栈，栈2进栈
        while(stack1.length>0) {
            stack2.push(stack1.pop());
        }
    }
    //栈2出栈，如果栈2内没有元素，就直接返回null
    return stack2.pop() || null;
}
```

#### 扩展：用两个队列实现栈
思路：进栈的时候，如果队列1为空，就进入队列1，如果不为空，就把队列1中的数据灌入到队列2中，然后再把将要入栈的数据插入队列1中，
出栈的时候，如果队列1不为空，就把队列1中的数据出队，如果为空再出队列2的。
```js
const queue1 = [];
const queue2 = [];
//进栈函数
function push(x) {
    if(queue1.length === 0) {
        queue1.push(x);
        //如果queueu2不为空，就一直出队
        while(queue2.length) {
            queue1.push(queue2.shift());  //shift()是删除数组中第一个元素，并返回删除的数的值
            //将队列2删除的数给队列1
        }
    }else if(queue2.length === 0) {
        queue2.push(queue1.shift());
        while(queue1.length) {
            queue2.push(queue1.shift());
        }
    }
}
//出栈的函数
function pop() {
    if(queue1.length != 0) {
        return queue1.shift();
    } else {
        return queue2.shift();
    }
}
```

### 3.2 包含min函数的栈
思路：

*   定义两个栈，一个用来存储数据，一个用来存最小的元素。
*   首先把数据进入数据栈
*   每次进栈的时候，都将进栈的数据和最小值栈的顶元素进行比较，如果比栈顶值小就把该数加入最小值栈
*   如果比最小值栈的栈顶元素大，那就把最小值栈的栈顶元素再次（复制）插入最小值栈中。
*   在出栈的时候，需要删除最小值栈的栈顶元素，即最小值栈和数据站都应该出栈。
*   这样最小值栈的栈顶元素就永远都是当前栈的最小值

以数据[3,4,2,7,9,0]为例，让这组数字依次如栈，则栈和其对应的最小值栈如下：
![](./img/栈和队列02.png)

```js
//首先定义两个栈
var dataStack = [];
var minStack = [];
//进栈函数
function push(node) {
    // 首选不管怎么，数据栈都会进栈
    dataStack.push(node);
    // 如果node比最小值栈的栈顶元素小那就把node进入最小值栈，否则就把最小值栈再次（复制）再次入最小值栈
    if (minStack.length === 0 || node < min()) {
        minStack.push(node);
    }else {
        minStack(min());
    }
}
//出栈函数
// 出栈的时候数据栈出栈，最小值栈删掉栈顶元素，
function pop() {
    minStack.pop();
    return dataStack.pop();
}
// 获取最小值栈的栈顶元素
function min() {
    var length = minStack.length;
    return minStack[length - 1]&&length > 0;  //栈不空才能返回
}
```

### 3.3 滑动窗口的最大值
给定一个数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧，你只可以看到在滑动窗口k内的数字，滑动窗口每次向右移动一位，返回滑动窗口最大值。
```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 
  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**思路**    
使用一个双端队列（队列两面都可以进出），用于存储处于窗口中的值的下标，保证窗口头部元素永远是窗口的最大值。
遍历每个滑块的起始点。
从起始点开始，遍历后续滑块元素。
对比滑块中元素的最大值，并存入结果。

```js
var maxSlidingWindow = function(nums,k) {
    let result = [];
    for(let i=0;i<nums.length-k+1;i++) {
        let max = nums[i];
        for(let i=0;i<j+k;j++) {
            max = Math.max(max,nums[j]);
        }
        //比对完整所有元素之后，将最大值存入result
        result.push(max);
    }
    return result;
}
```

### 3.4 栈的引入和弹出，序列

[题目]
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。
假设压入栈的所有数字均不相等。
例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
（注意：这两个序列的长度是相等的）

> 题目来源：牛客网-剑指offer

思路：

*   首先判断给出的这两个栈序列是否存在并且不为空
*   然后借助一个工作站，来存放压入栈的弹出过程
*   遍历压入栈，然后依次存入工作站中
*   如果工作栈的栈顶元素和弹出栈的栈顶元素相同，工作站就出栈，并且弹出栈的索引往后移
*   如果不同就继续将压入栈元素压入工作栈继续，相当于入栈
*   最后如果工作站为空就说明第二个序列是第一个序列的弹出顺序
![](./img/栈和队列03.png)

```js
//传入两个栈序列，一个是压入栈，一个是弹出栈
function IsPopOrder(pushV,popV) {
    //首先判断这两个栈是否存在并且不为空
    if(pushV || popV || pushV.length === 0 || popV.length === 0 ) {
        return;
    } 
    var workStack = [];  //定义一个工作栈
    var outIndex = 0;  //在弹出栈中移动的索引
    for(var i=0;i<pushV.length;i++) {
        // 从栈底开始把压入栈的元素放入工作栈中
        workStack.push(pushV[i])
        //工作栈栈顶元素和弹出栈索引位置相同的话，工作站出栈，并且索引后进一位
        while(workStack.length && workStack[workStack.length - 1] === popV[outIndex]) {
            workStack.pop();
            outIndex ++;
        }
    }
    // 如果工作栈最后为空，说明弹出栈就是压入栈的出栈序列
    return workStack.length === 0;
}
```

## 4.链表
链表与数组不同，链表中的元素在内存中不必是连续的内存空间。  
链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。

相对于数组，链表有一些优点：
- 内存空间不是必须连续的，可以充分利用计算机的内存，实现灵活的内存动态管理。
- 链表不必在创建时确定大小，并且大小可以无限的延伸下去。
- 链表在插入和删除数据时，时间复杂度可以达到O(1),相对数组效率高很多。

相对于数组，链表的缺点：
- 链表访问任何一个位置的元素时，都需要从头开始访问。
- 无法通过下标直接访问元素，需要从头一个个访问，直到找到对应元素。

### 4.1 链表的定义（单向链表）
链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（有的语言称为指针或连接）组成。类似于火车头，一节车厢载着乘客（数据），通过节点连接另一节车厢。
![](img/链表01.png)

head属性指向链表的第一个节点；  
链表中的最后一个节点指向null；  
当链表中一个节点也没有的时候，head直接指向null；
![](img/链表02.png)

### 4.2 单向链表的封装

```js
function LinkedList() {
    //内部的类：节点类
    function Node(data) {
        this.data = data;
        this.next = null;
    }
    //属性
    this.head = null;
    this.length = 0;
}
```

### 4.3 链表中常见方法

- append（element）：向链表尾部添加一个新的项；
- insert（position，element）：向链表的特定位置插入一个新的项；
- get（position）：获取对应位置的元素；
- indexOf（element）：返回元素在链表中的索引。如果链表中没有该元素就返回-1；
- update（position，element）：修改某个位置的元素；
- removeAt（position）：从链表的特定位置移除一项；
- remove（element）：从链表中移除一项；
- isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；
- size（）：返回链表包含的元素个数，与数组的length属性类似；
- toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；

#### 4.3.1 append()
```js
LinkedList.prototype.append = data => {
        //1.创建新的节点
        let newNode = new Node(data);

        // 2.判断添加的是否是第一个节点
        if(this.length == 0) {  //2.1 是第一个节点
            this.head = newNode;
        }else {  //2.2 不是第一个节点
            let current = this.head;
            //找到最后一个节点
            while(current.next) {
                current = current.next;
            }
            //最后节点的next指向新的节点
            current.next = newNode;
        }
        //3.lenght+1
        this.length += 1;
    }
```
**过程：**
- 首先链表是否为空，如果为空直接把新的节点插到头结点后面。
- 让current节点指向头结点
![](img/链表03.png)

- 通过while循环使current遍历到最后一个节点，最后让最后一个节点指向新节点newNode：
![](img/链表04.png)

**测试：**
```js
let list = new LinkedList();
list.append('123');
list.append('234');
list.append('345');
console.log(list);
```

结果：

![](img/链表05.png)

#### 4.3.2 toString()

```js
 LinkedList.prototype.toString = () => {
        //定义变量
        let current = this.head;
        let listString = "";
        while(current) {
            listString += current.data + " ";
            current = current.next;
        }
        return listString;
    }

// 测试：
console.log(list.toString());  //123 234 345 
```

#### 4.3.3 insert()
```js
LinkedList.prototype.insert = (position,data) => {
        //1.对position进行跨界判断
        if(position < 0 || position > this.length) {
            return false;
        }
        // 根据datac创建Node
        let newNode = new Node(data);

        ////判断插入的位置
        if(position == 0) {
            newNode.next = this.head;
            this.head = newNode;          
        }else{
            let index = 0;
            let current = this.head;
            let previous = null;
            while(index < position) {
                previous = current;
                current = current.next;
                index += 1;
            }
            newNode.next = current;
            previous.next = newNode;
        }
        this.length += 1;
        return true;
    }
```

**过程：**
inset方法实现的过程：根据插入节点位置的不同可分为多种情况：
- 情况一：position=0    

通过： newNode.next = this.head，建立连接1；    
通过： this.head = newNode，建立连接2；（不能先建立连接2，否则this.head不再指向Node1）

![](img/链表06.png)

- 情况二：position>0 || position < length

首先定义两个变量previous和curent分别指向需要插入位置pos = X的前一个节点和后一个节点；       
然后，通过：newNode.next = current，改变指向3；     
最后，通过：previous.next = newNode，改变指向4；

![](img/链表07.png)

- 情况三：position = length
情况2也包含了pos = length的情况，该情况下current和newNode.next都指向null；建立连接3和连接4的方式与情况2相同。

![](img/链表08.png)

**测试：**
```js
list.insert(0,"000")
console.log(list.toString());  //000 123 234 345 
list.insert(2,"111");
console.log(list.toString());  //000 123 111 234 345 
list.insert(list.length,'333');
console.log(list.toString());  //000 123 111 234 345 333 
```

#### 4.3.4 get(position)
```js

LinkedList.prototype.get = (position) => {
        if(position < 0 || position >= this.length) {
            return null;
        }
        // 获取对应的data
        let current = this.head;
        let index = 0;
        while(index < position) {
            current = current.next;
            index += 1;
        }
        return current.data;
    }
}
```
测试get()方法：
```js
// 测试get方法
console.log(list.get(1));  //123
```

#### 4.3.5 indexOf()方法
```js
LinkedList.prototype.indexOf = (str) => {
        let current = this.head;
        let index = 0;
        while(current.data !== str && index < this.length){
            current = current.next;
            index += 1;
        }
        return index;
    }

// 测试indexOf()
console.log(list.indexOf('333')); //5
```

#### 4.3.6 updata()方法
```js
 LinkedList.prototype.updata = (position,newData) => {
        if(position < 0 || position > this.length) {
            return  false;
        }
        let current = this.head;
        let index = 0;
        while(index++ < position) {
            current = current.next;
        }
        //将position位置的data修改成newData
        current.data = newData;
        return true;
    }

//测试updata()
list.updata(2,"new222");
console.log(list.toString());  //000 123 new222 234 345 333 
```

#### 4.3.7 removeAt()方法

```js
LinkedList.prototype.removeAt = position => {
        if(position < 0 || position >= this.length) {
            return null;
        }
        let current = this.head;
        let index = 0;
        if(position == 0) {  //如果删除第一个元素，就直接把头指针指向下一个元素即可
            this.head = this.head.next;
        }else {
            let previous = null;
            while (index++ < position) {
                previous = current
                current = current.next
              }
            //循环结束后，current指向position后一个节点，previous指向current前一个节点
            //再使前一个节点的next指向current的next即可
            previous.next = current.next
        }
        this.length -- ;
        // 返回删除的节点数据
        return current.data;
    }

//测试removeAt(position)
list.removeAt(2);
console.log(list.toString());
//000 123 234 345 333 
```
removeAt方法的实现过程：删除节点时存在多种情况：

- 情况1：position = 0，即移除第一个节点（Node1）。

通过：this.head = this.head.next，改变指向1即可；

虽然Node1的next仍指向Node2，但是没有引用指向Node1，则Node1会被垃圾回收器自动回收，所以不用处理Node1指向Node2的引用next。

![](./img/链表09.png)

- 情况2：positon > 0，比如pos = 2即移除第三个节点（Node3）。

注意：position = length时position后一个节点为null不能删除，因此position != length；

首先，定义两个变量previous和curent分别指向需要删除位置pos = x的前一个节点和后一个节点；

然后，通过：`previous.next = current.next`，改变指向即可；

随后，没有引用指向Node3，Node3就会被自动回收，至此成功删除Node3 。

![](./img/链表10.png)

#### 4.3.8 其他方法
```js
      //一.实现remove方法
      LinkList.prototype.remove = (data) => {
        //1.获取data在列表中的位置
        let position = this.indexOf(data)
        //2.根据位置信息，删除结点
        return this.removeAt(position)
      }

      //二.实现isEmpty方法
      LinkList.prototype.isEmpty = () => {
        return this.length == 0
      }

      //三.实现size方法
      LinkList.prototype.size = () => {
        return this.length
      }
```

## 4.双向链表

**双向链表：**既可以**从头遍历到尾**，又可以**从尾遍历到头**。也就是说链表连接的过程是双向的，它的实现原理是：一个节点既有向前连接的引用，也有一个向后连接的引用。
**双向链表的缺点**：
- 每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些；
- 相对于单向链表，所占内存空间更大一些；
- 但是，相对于双向链表的便利性而言，这些缺点微不足道。

**双向链表的结构：**

![](./img/双向链表01.png)

- 双向链表不仅有head指针指向第一个节点，而且有tail指针指向最后一个节点；
- 每一个节点由三部分组成：item储存数据、prev指向前一个节点、next指向后一个节点；
- 双向链表的第一个节点的prev指向null；
- 双向链表的最后一个节点的next指向null；

### 4.1 双向链表常见的操作（方法）

- append（element）：向链表尾部添加一个新的项；
- inset（position，element）：向链表的特定位置插入一个新的项；
- get（element）：获取对应位置的元素；
- indexOf（element）：返回元素在链表中的索引，如果链表中没有元素就返回-1；
- update（position，element）：修改某个位置的元素；
- removeAt（position）：从链表的特定位置移除一项；
- isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；
- size（）：返回链表包含的元素个数，与数组的length属性类似；
- toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；
- forwardString（）：返回正向遍历节点字符串形式；
- backwordString（）：返回反向遍历的节点的字符串形式；

### 4.2 双向链表的封装

```js
function DoublyLinkedList() {

    // 内部类
    function Node(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
    // 属性
    this.head = null;
    this.tail = null;
    this.length = 0;
}
```

#### 4.2.1 append()方法

```js
DoubleLinklist.prototype.aapend(data) {
        //1.创建一个新的节点
        let newNode = new Node(data);
        
        //2。添加节点
        //2.1如果是第一个节点
        if(this.length === 0) {
            this.head = newNode;
            this.tail = newNode;
        }else {
            //2.2如果不是第一个节点
            let current = this.head;

            while(current.next !== null) {
                current = current.next;
            }
            newNode.next =  this.tail.next;
            this.tail.next = newNode;
            newNode.prev = this.tail;
        }
        //3.改变链表的length
        this.length += 1;
    }
```
过程分析：
添加的节点需要考虑多种情况：
- 情况1：添加的是第一个节点：只需要让head和tail都指向新节点即可；

![](./img/双向链表02.png)

- 情况2：添加的不是第一个节点，如下图所示：只需要改变相关引用的指向即可。

* 通过：`newNode.prev = this.tail`：建立指向1；
* 通过：`this.tail.next = newNode`：建立指向2；
* 通过：`this.tail = newNode`：建立指向3  
要注意改变变量指向的顺序，最后修改tail指向，这样未修改前tail始终指向原链表的最后一个节点。

![](./img/双向链表03.png)

![](./img/双向链表04.png)

测试：
```js
let list = new DoubleLinklist();
list.append('111');
list.append('222');
list.append('333');
console.log(list);
```
#### 4.2.2 转成字符串方法
```js
// 转成字符串形似方法
    DoubleLinklist.prototype.toString = () => {
        //因为toString方法一般都是从头开始遍历，所以直接调用forwardString方法即可
        return this.backwardString();

    }
    //forwardString方法 向前遍历
    DoubleLinklist.prototype.forwardString = () => {
        let retString = ''
        let current = this.tail;

        if(this.length === 0) {
            return null;
        }
        while(current) {
            retString += current.data + ' ';
            current = current.prev;
        }
        return retString;
    }
    //backwardString方法 向后遍历
    DoubleLinklist.prototype.backwardString = () => {
        let current = this.head;
        let retString = '';  
        
        if(this.length === 0) {
            return null;
        }
        
        while(current) {
            retString += current.data + ' ';
            current = current.next;
        }
        return retString;
    }
```
测试：
```js
console.log(list.toString());  //111 222 333 
console.log(list.forwardString());  //333 222 111 
console.log(list.backwardString()); //111 222 333 
```
#### 4.2.3 插入方法 insert

```js
DoubleLinklist.prototype.insert = (position,data) => {
        //跨界判断
        if(position < 0 || position > this.length) {
            return false;
        }
        //插入新节点
        let newNode = new Node(data);
        //1.如果插入的节点在表头
        if(this.length == 0) {
            this.head = newNode;
            this.tail = newNode;
            //2.插入表末尾
        } else if (position == this.length) {
            this.tail.next = newNode;
            newNode.prev = this.tail;
            this.tail = newNode;
        } else { //3.插入表中间
            let current = this.head;
            let index = 0;

            while(index++ < position) {
                current = current.next;
            }
            newNode.prev = current.prev;
            current.prev.next = newNode;
            current.prev = newNode;
            newNode.next = current;
        }
    }
```

过程分析：
插入节点可分为多种情况：

**当原链表为空时：**

- 情况1：插入的新节点是链表的第一个节点；只需要让head和tail都指向newNode即可。

![](./img/双向链表05.png)

**当原链表不为空时：**

- 情况2：当position == 0，即在链表的首部添加节点：如下图所示：

![](./img/双向链表06.png)

首先，通过：`this.head.prev = newNode`，改变指向1；

然后，通过：`newNode.next = this.head`，改变指向2；

最后，通过：`this.head = newNode`，改变指向3；

![](./img/双向链表07.png)

- 情况3：`position == this.length`，即在链表的尾部添加节点，如下图所示：

![](./img/双向链表08.png)

首先，通过：`this.tail.next = newNode`，改变指向1；（注意这里使用this.tail指向原链表最后一个节点，而不是`this.head`。因为当`length>1`时，`this.head != this.tail`。）

然后，通过：`newNode.prev = this.tail`，改变指向2；

最后，通过：`this.tail = newNode`，改变指向3；

![](./img/双向链表09.png)

- 情况4：0 < position < this.length，即在链表的中间插入新节点，假设在position = 1的位置插入，如下图所示：

![](./img/双向链表10.png)

首先，需要定义变量current按照之前的思路，通过while循环找到position位置的后一个节点，循环结束后`index = position`

如下图所示：当position = 1时，current就指向了Node2。这样操作current就等同于间接地操作Node2，还可以通过current.prev间接获取Node1。得到了newNode的前一个节点和后一个节点就可以通过改变它们的prev和next变量的指向来插入newNode了。

![](./img/双向链表11.png)

通过：`newNode.next = current`，改变指向1；

通过：`newNode.prev = current.prev`，改变指向2；

通过：`current.prev.next = newNode`，改变指向3；

注意必须最后才修改`current.prev`的指向，不然就无法通过`current.prev`获取需要操作的Node1了。

通过：`current.prev = current`，改变指向4；

![](./img/双向链表12.png)

**测试：**
```js
list.insert(2,'00000');
list.insert(0,'插在链表的头部');
list.insert(list.length,'插在链表的尾部');
console.log(list.toString());

```

`**结果：**`        
`插在链表的头部 111 222 00000 333 插在链表的尾部 `

#### 4.2.4 get(position)
```js
DoubleLinklist.prototype.get = (position) => {
        //越界判断
        if(position < 0 || position >= this.length) {
            return null;
        }
        //获取元素
        let current = this.head;
        let index = 0;
        while(index < position) {
            current = current.next;
            index ++;
        }
        return current.data;
    }
```
测试：
```
console.log(list.get(3));  //00000
```

#### 4.2.5 indexOf方法实现
```js
DoubleLinklist.prototype.indexOf = (data) => {
        let current = this.head;
        let index = 0;

        while(current) {
            if(current.data === data) {
                return index;
            }
            current = current.next;
            index ++;
        }
        return -1;  //找不到
    }
```
测试：
```js
console.log(list.indexOf('00000'));  //3
```

#### 4.2.6 update(position,element)
```js
DoubleLinklist.prototype.updata = (position,newData) => {
        //越界判断
        if(position < 0 || position >= this.length) {
            return false;
        }
        let current = this.head;
        let index = 0;
        while(index < position) {
            current = current.next;
            index ++;
        }
        current.data = newData;
        return true;
    }
```
测试：
```js
list.updata(3,'aaa');
console.log(list.toString()); 
//插在链表的头部 111 222 00000 333 插在链表的尾部 
```

#### 4.2.7 removeAt(position)
```js
DoubleLinklist.prototype.removeAt = (position) => {
        //越界判断
        if(position < 0 || position > this.length) {
            return null;
        }
        let current = this.head; 
        //链表中只有一个元素
        if(this.length === 0) {
            this.head = null;
            this.tail = null;
        }else {
            //判断是否删除的是第一个元素
            if(position == 0) {
                this.head.next.prev = null;
                this.head = this.head.next;
            }else if(position == this.length - 1){  //删除最后一个节点
                current = this.tail;  //接受被返回的删除的节点
                this.tail.prev.next = null;
                this.tail = current.prev;
            } else { //删除中间的节点
                let index = 0;
                while(index < position) {
                    current = current.next;
                    index += 1;
                }
                current.prev.next = current.next;
                current.next.prev = current.prev;
            }
        }
        this.length --;
        return current.data;
    }
```

**过程详解：**

删除节点时有多种情况：

**当链表的length = 1时:**

- 情况1：删除链表中的所有节点：只需要让链表的head和tail指向null即可。

![](./img/双向链表13.png)

**当链表的length > 1时：**

- 情况2：删除链表中的第一个节点：

通过：`this.head.next.prev = null`，改变指向1；

通过：`this.head = this.head.next`，改变指向2；

虽然Node1有引用指向其它节点，但是没有引用指向Node1，那么Node1会被自动回收。

![](./img/双向链表14.png)

- 情况3：删除链表中的最后一个节点：

通过：`this.tail.prev.next = null`，修改指向1；

通过：`this.tail = this.tail.prev`，修改指向2；

![](./img/双向链表15.png)

- 情况4：删除链表中间的节点：

通过while循环找到需要删除的节点，比如position = x，那么需要删除的节点就是Node(x+1)，如下图所示：

![](./img/双向链表16.png)

通过：`current.next.prev = current.prev`，修改指向1；

通过：`current.prev.next = current.next`，修改指向2；

这样就没有引用指向Node(x+1)了（current虽指向Node(x+1)，但current时临时变量，该方法执行完就会被销毁），随后Node(x+1)就会被自动删除。

![](./img/双向链表17.png)

**测试**

```js
let re = list.removeAt(3);
console.log("删除的节点是：" + re);
console.log(list.toString());
// 删除的节点是：00000
//插在链表的头部 111 222 333 插在链表的尾部 
```

#### 4.2.8 其他方法
其他方法包括：remove(element)、isEmpty()、size()、getHead()、getTail()

```js

    //remove()
    DoubleLinklist.prototype.remove = () =>  {
        //找到data的索引
        let index = this.indexOf(data);

        //删除这个索引位置对应的元素
        this.removeAt(index);

        return index;
    }

    //isEmpty()
    DoubleLinklist.prototype.isEmpty = () => {
        return this.length === 0;
    }
    //size()
    DoubleLinklist.prototype.size = () => {
         return this.length;
    }
    //getHead()
    DoubleLinklist.prototype.getHead = () => {
        return this.head.data;
    }
    //getTail() 
    DoubleLinklist.prototype.getTail = () => {
        return this.tail.data;
    }
```

## 5.集合结构
几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。

### 5.1 集合的特点
- 集合通常是由一组无序的、不能重复的元素构成。

- 数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。
- 集合是特殊的数组。

    * 特殊之处在于里面的元素没有顺序，也不能重复。
    * 没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存在一份。

### 5.2 封装集合
ES6 中的 Set 就是一个集合类，这里我们重新封装一个 Set 类，了解集合的底层实现。

#### 5.2.1 集合常见的操作
- `add(value) `向集合添加一个新的项。
- `remove(value`) 从集合移除一个值。
- `has(value) `如果值在集合中，返回 true，否则返回 false。
- `clear()` 移除集合中的所有项。
- `size() `返回集合所包含元素的数量。与数组的 length 属性类似。
- `values() `返回一个包含集合中所有值的数组。
还有其他的方法，用的不多，这里不做封装。

#### 5.2.2 集合封装代码实现
```js
//集合结构的封装
class Set {
    constructor() {
        this.items = [];
    }

    //has(value)判断集合中是否存在value这个属性，存在返回true，否则返回false
    has(value) {
        return this.items.hasOwnProperty(value); //hasOwnProperty检测一个属性是否是自身的属性而不是原型的属性
    };

    //add(value) 往集合中添加value
    add(value) {
        // 首先检测集合中是否包含这个属性（值）
        if(this.has(value)) {
            return false;
        }
        this.items[value] = value; //属性名和值都是value
        return true;
    }

    //remove(value) 删除集合中指定的value
    remove(value) {
        //如果集合中不存在这个value，则范湖false
        if(!this.has(value)) {
            return false;
        }
        delete this.items[value];
    }

    //clear()情况所有的value
    clear() {
        this.items = {};
    }

    //size() 返回集合中value的个数
    size() {
        return Object.keys(this.items).length;
    }

    //values() 获取集合中所有的value
    values() {
        return Object.keys(this.items);
    }
}
```

**代码测试：**
```js
const set = new Set();
// add()测试
set.add('111');
set.add('222');
set.add('333');
set.add('444');

//values()测试
console.log(set.values());  //[ '111', '222', '333', '444' ]

//has()测试
console.log(set.has('222')); //true
console.log(set.has('000'));  //false

// size()和remove()测试
console.log(set.size());  //4
set.remove('222');
console.log(set.size());  //3
console.log(set.values());  //[ '111', '333', '444' ]

//clear()测试
set.clear()
console.log(set.values());  // []
```

### 5.3 集合间的操作
- 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。
- 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。
- 差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。
- 子集：验证一个给定集合是否是另一个集合的子集。

![](./img/集合01.png)

#### 5.3.1 集合并集的实现
- 并集的实现
```js
    union(otherSet) {
        //1.创建一个新的集合
        let newSet = new Set();

        //2.将当前集合的value添加到新集合newSet中
        for(let value of this.values()) {
            newSet.add(value);
        } 

        //3.将otherSet集合中的所有value，添加到新集合newSet中
        for(let value of otherSet.values()) {
            newSet.add(value);  //这里add已经有重复判断了
        }
        return  newSet;
    }
```

- 交集实现
```js
    intersection(otherSet) {
        //创建一个新的集合
        let newSet = new Set();

        //从当前集合中选出每个元素都判断在otherSet中是否存在
        for(let value of this.values()) {
            if(otherSet.has(value)) {
                newSet.add(value);
            }
        }
        return newSet;
    }
```
- 差集实现
```js
    difference(otherSet) {
        //创建一个新集合
        let newSet = new Set();

        //从当前集合中取出每一个value，判断是否在otherSet集合中存在，不存在的就是差集
        for(let value of this.values()) {
            if(!otherSet.has(value)) {
                newSet.add(value);
            }
        }
        return newSet;
    }
```

- 子集的实现

```js
    subset(otherSet) {
        //从当前集合中取出每一个value判断是否在otherSet集合中存在，有不存在的返回false
        //如果能遍历完所有的，说明就是自己，返回true
        for(let value of this.values()) {
            if(!otherSet.has(value)) {
                return false;
            }
            return true;
        }
    }
```

**测试：**
```js
set = ['111','222','333','444']
otherSet = ['aaa','bbb','ccc','222']

console.log(set.union(otherSet).values()); 
//  ["111", "222", "333", "444", "aaa", "bbb", "ccc"]

console.log(set.intersection(otherSet).values());  //["333"]

console.log(set.difference(otherSet).values());  //["111", "222", "444"]

console.log(set.subset(otherSet));  //false
```



























-------------
更新新中....

